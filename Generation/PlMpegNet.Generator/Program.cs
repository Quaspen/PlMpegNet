using Hebron.Roslyn;
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace StbSharp.StbImage.Generator
{
	class Program
	{
		private static readonly Regex RegexTwoParam = new Regex(@"\{\s*([-\w\s<]+)\s*,\s*([-\w\s<]+)\s*\}");
		private static readonly Regex RegexThreeParam = new Regex(@"\{\s*([-\w\s<]+)\s*,\s*([-\w\s<]+)\s*,\s*([-\w\s<]+)\s*\}");

		private static string Write<T>(Dictionary<string, T> input) where T : SyntaxNode
		{
			var keys = (from string k in input.Keys select k).ToArray();
			var result = string.Empty;
			foreach (var key in keys)
			{
				using (var sw = new StringWriter())
				{
					input[key].NormalizeWhitespace().WriteTo(sw);

					result += sw.ToString();
					result += Environment.NewLine;
				}

			}

			return result;
		}

		private class Writer
		{
			private readonly StringBuilder sb = new StringBuilder();

			public Writer()
			{
				sb.AppendLine(string.Format("// Generated by Hebron at {0}", DateTime.Now));
				sb.AppendLine();

				sb.AppendLine("using System;");
				sb.AppendLine("using System.Runtime.InteropServices;");
				sb.AppendLine("using Hebron.Runtime;");

				sb.AppendLine();

				sb.Append("namespace PlMpegSharp\n{\n\t");
				sb.AppendLine("unsafe partial class PlMpeg\n\t{");
			}

			public void Write<T>(Dictionary<string, T> input, Func<string, string, string> beforeWrite = null) where T : SyntaxNode
			{
				var keys = (from string k in input.Keys select k).ToArray();
				foreach (var key in keys)
				{
					string data;
					using (var sw = new StringWriter())
					{
						var s = input[key].NormalizeWhitespace();
						s.WriteTo(sw);

						data = sw.ToString();
					}

					if (beforeWrite != null)
					{
						data = beforeWrite(key, data);
					}

					sb.AppendLine(data);
				}
			}

			public void WriteEmptyLine()
			{
				sb.AppendLine();
			}

			public string Finish()
			{
				sb.Append("}\n}");
				return sb.ToString();
			}
		}

		private static string ReplaceMallocWithConstructor(string data, string name)
		{
			data = data.Replace($"({name})(CRuntime.malloc((ulong)(sizeof({name}))))", $"new {name}()");
			data = data.Replace($"CRuntime.memset(self, (int)(0), (ulong)(sizeof({name})));", "");

			return data;
		}

		private static string ReplaceArray(string data, string name) 
		{
			var regex = new Regex(@$"{name}\[([\w\s\&]+)\]\[([\w\s\&]+)\]\[");
			data = regex.Replace(data, $"{name}[$1, $2, ");

			regex = new Regex(@$"{name}\[([\w\s\&]+)\]\[");
			data = regex.Replace(data, $"{name}[$1, ");


			return data;
		}

		static void Process()
		{
			var parameters = new RoslynConversionParameters
			{
				InputPath = @"pl_mpeg.h",
				Defines = new[]
				{
					"PL_MPEG_IMPLEMENTATION",
					"PLM_NO_STDIO"
				},
				SkipStructs = new string[]
				{
				},
				SkipGlobalVariables = new string[]
				{
					"PlMpegi_mat_transform_fns",
					"PlMpegi_real_sum_fns"
				},
				SkipFunctions = new[]
				{
					"plm_buffer_read_vlc_uint",
					"plm_buffer_tell",
				},
				Classes = new string[]
				{
					"plm_samples_t",
					"plm_packet_t",
					"plm_frame_t"
				},
			};

			var result = RoslynCodeConverter.Convert(parameters);

			// Write output
			var writer = new Writer();
			writer.Write(result.NamedEnums);
			File.WriteAllText(@"..\..\..\..\..\..\src\PlMpeg.Enums.Generated.cs", writer.Finish());

			writer = new Writer();
			writer.Write(result.UnnamedEnumValues);
			writer.WriteEmptyLine();
			writer.Write(result.GlobalVariables, (key, s) =>
			{
				if (key == "PLM_VIDEO_PIXEL_ASPECT_RATIO" ||
					key == "PLM_AUDIO_SYNTHESIS_WINDOW")
				{
					var regex = new Regex(@"([-\d\.]+)([,}])");
					s = regex.Replace(s, "$1f$2");
				}

				if (key == "PLM_VIDEO_DCT_COEFF")
				{
					s = RegexTwoParam.Replace(s, "new plm_vlc_uint_t($1, $2)");
				}

				if (key == "PLM_AUDIO_QUANT_TAB")
				{
					s = RegexThreeParam.Replace(s, "new plm_quantizer_spec_t($1, $2, $3)");
				}

				return s;
			});

			var s = writer.Finish();

			s = RegexTwoParam.Replace(s, "new plm_vlc_t($1, $2)");
			s = s.Replace("plm_vlc_t[, ] PLM_VIDEO_MACROBLOCK_TYPE = new plm_vlc_t[]", "plm_vlc_t[][] PLM_VIDEO_MACROBLOCK_TYPE = new plm_vlc_t[][]");
			s = s.Replace("plm_vlc_t[, ] PLM_VIDEO_DCT_SIZE = new plm_vlc_t[]", "plm_vlc_t[][] PLM_VIDEO_DCT_SIZE = new plm_vlc_t[][]");

			var regex = new Regex(@"byte\[\s*,\s*\]\s*([\w_]+)\s*=\s*new\s*byte\[\]");
			s = regex.Replace(s, "byte[,] $1 = new byte[,]");

//			File.WriteAllText(@"..\..\..\..\..\..\src\PlMpeg.GlobalVariables.Generated.cs", s);

			writer = new Writer();
			writer.Write(result.Structs);
//			File.WriteAllText(@"..\..\..\..\..\..\src\PlMpeg.Structs.Generated.cs", writer.Finish());

			writer = new Writer();
			writer.Write(result.Delegates);
			writer.WriteEmptyLine();
			writer.Write(result.Functions);

			var data = writer.Finish();
			data = ReplaceMallocWithConstructor(data, "plm_t");
			data = ReplaceMallocWithConstructor(data, "plm_buffer_t");
			data = ReplaceMallocWithConstructor(data, "plm_demux_t");
			data = ReplaceMallocWithConstructor(data, "plm_video_t");
			data = ReplaceMallocWithConstructor(data, "plm_audio_t");

			data = data.Replace("CRuntime.free(self);", "");
			data = data.Replace("while ((packet = plm_demux_decode(self.demux)))", "while ((packet = plm_demux_decode(self.demux)) != null)");
			data = data.Replace("while ((packet = plm_demux_decode(self)))", "while ((packet = plm_demux_decode(self)) != null)");

			regex = new Regex(@"\(plm_buffer_mode\)\(([\w_]+)\)");
			data = regex.Replace(data, "plm_buffer_mode.$1");

			data = data.Replace("(PLM_BUFFER_MODE_FIXED_MEM)", "plm_buffer_mode.PLM_BUFFER_MODE_FIXED_MEM");
			data = data.Replace("(PLM_BUFFER_MODE_RING)", "plm_buffer_mode.PLM_BUFFER_MODE_RING");
			data = data.Replace("(PLM_BUFFER_MODE_FILE)", "plm_buffer_mode.PLM_BUFFER_MODE_FILE");

			data = data.Replace("plm_buffer_tell(self.buffer) - previous_pos)", "plm_buffer_tell(self.buffer) - (ulong)previous_pos)");
			data = data.Replace("file_size - range", "(int)file_size - range");
			data = data.Replace("void* user", "plm_t user");

			data = data.Replace("delegate0(plm_t arg0, plm_frame_t* arg1, void* arg2)", "delegate0(plm_t arg0, plm_frame_t* arg1, object arg2)");
			data = data.Replace("delegate1(plm_t arg0, plm_samples_t arg1, void* arg2)", "delegate1(plm_t arg0, plm_samples_t arg1, object arg2)");
			data = data.Replace("delegate2(plm_buffer_t arg0, void* arg1)", "delegate2(plm_buffer_t arg0, plm_t arg1)");
			data = data.Replace("delegate3(plm_buffer_t arg0, ulong arg1, void* arg2)", "delegate3(plm_buffer_t arg0, ulong arg1, plm_t arg2)");

			data = data.Replace("CRuntime.memcpy(self.D, PLM_AUDIO_SYNTHESIS_WINDOW, (ulong)(512 * sizeof(float)))", "Array.Copy(PLM_AUDIO_SYNTHESIS_WINDOW, self.D, 512)");
			data = data.Replace("CRuntime.memcpy(self.D + 512, PLM_AUDIO_SYNTHESIS_WINDOW, (ulong)(512 * sizeof(float)))", "Array.Copy(PLM_AUDIO_SYNTHESIS_WINDOW, 0, self.D, 512, 512)");

			data = data.Replace("CRuntime.memcpy(self.intra_quant_matrix, PLM_VIDEO_INTRA_QUANT_MATRIX, (ulong)(64))", "Array.Copy(PLM_VIDEO_INTRA_QUANT_MATRIX, self.intra_quant_matrix, 64)");
			data = data.Replace("CRuntime.memcpy(self.non_intra_quant_matrix, PLM_VIDEO_NON_INTRA_QUANT_MATRIX, (ulong)(64))", "Array.Copy(PLM_VIDEO_NON_INTRA_QUANT_MATRIX, self.non_intra_quant_matrix, 64)");
			data = data.Replace("byte* quant_matrix;", "byte[] quant_matrix;");

			data = data.Replace("(plm_vlc_t)(stackalloc plm_vlc_t[]{0, 0}; )", "new plm_vlc_t()");
			data = data.Replace("return (int)(val != 0);", "return (int)(val != 0?1:0);");
			data = data.Replace("plm_vlc_t* table = PLM_VIDEO_MACROBLOCK_TYPE[self.picture_type]", "var table = PLM_VIDEO_MACROBLOCK_TYPE[self.picture_type]");
			data = data.Replace("CRuntime.memset(self.block_data, (int)(0), (ulong)(64 * sizeof(int)))", "self.block_data.ArraySet(0)");
			data = data.Replace("int hasCRC = (int)(!plm_buffer_read(self.buffer, (int)(1)));", "var hasCRC = plm_buffer_read(self.buffer, (int)(1)) == 0;");
			data = data.Replace("(hasCRC) != 0", "hasCRC");

			data = ReplaceArray(data, "PLM_AUDIO_QUANT_LUT_STEP_1");
			data = ReplaceArray(data, "PLM_AUDIO_QUANT_LUT_STEP_3");
			data = ReplaceArray(data, "PLM_AUDIO_QUANT_LUT_STEP_4");
			data = ReplaceArray(data, "QUANT_LUT_STEP_2");
			data = ReplaceArray(data, "self.allocation");
			data = ReplaceArray(data, "self.scale_factor_info");
			data = ReplaceArray(data, "self.scale_factor");

			data = data.Replace("int* s = self.block_data", "var s = self.block_data");
			data = data.Replace("plm_video_idct(int* block)", "plm_video_idct(int[] block)");
			data = data.Replace("plm_quantizer_spec_t*", "plm_quantizer_spec_t?");
			data = data.Replace("(qtab) != 0 ? (&PLM_AUDIO_QUANT_TAB[qtab - 1]) : null", "(qtab) != 0 ? (PLM_AUDIO_QUANT_TAB[qtab - 1]) : default");
			data = data.Replace("int* sf = self.scale_factor[ch, sb];", "");
			data = data.Replace("sf[", "self.scale_factor[ch, sb, ");
			data = data.Replace("plm_audio_idct36(int** s, int ss, float*", "plm_audio_idct36(int[][] s, int ss, float[]");
			data = data.Replace("CRuntime.memset(self.U, (int)(0), (ulong)(32 * sizeof(float)))", "self.U.ArraySet(0)");
			data = data.Replace("int* sample = self.sample[ch][sb]", "var sample = self.sample[ch][sb]");
			data = data.Replace("q->", "q.");
			data = data.Replace("plm_packet_t*", "plm_packet_t?");

			File.WriteAllText(@"..\..\..\..\..\..\src\PlMpeg.Functions.Generated.cs", data);
		}

		static void Main(string[] args)
		{
			try
			{
				Process();
			}
			catch (Exception ex)
			{
				Console.WriteLine(ex.Message);
				Console.WriteLine(ex.StackTrace);
			}

			Console.WriteLine("Finished. Press any key to quit.");
			Console.ReadKey();
		}
	}
}